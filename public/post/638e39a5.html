<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
<!-- Referrer Policy调整致不蒜子单页面统计出错:https://senorui.top/posts/c33f.html -->
<meta name="referrer" content="no-referrer-when-downgrade">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/blogAvatar.jpeg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/blogAvatar.jpeg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="什么是Protobuf在网络通信和通用数据交换等应用场景中经常使用的技术是 JSON 或 XML，还有一种类型Protobuf。 Protobuf是Protocol Buffers的简称，它是Google出品的性能优异、跨语言、跨平台的序列化库，用于描述一种轻便高效的结构化数据存储格式，并于2008年对外开源。Protobuf可以用于结构化数据串行化，或者说序列化。它的设计非常适用于在网络通讯中的">
<meta property="og:type" content="article">
<meta property="og:title" content="Protobuf入门">
<meta property="og:url" content="http://example.com/post/638e39a5.html">
<meta property="og:site_name" content="Sun">
<meta property="og:description" content="什么是Protobuf在网络通信和通用数据交换等应用场景中经常使用的技术是 JSON 或 XML，还有一种类型Protobuf。 Protobuf是Protocol Buffers的简称，它是Google出品的性能优异、跨语言、跨平台的序列化库，用于描述一种轻便高效的结构化数据存储格式，并于2008年对外开源。Protobuf可以用于结构化数据串行化，或者说序列化。它的设计非常适用于在网络通讯中的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/gods-view/images/master/imageimage-20220818145636178.png">
<meta property="article:published_time" content="2022-08-19T05:46:17.000Z">
<meta property="article:modified_time" content="2022-08-19T09:53:07.908Z">
<meta property="article:author" content="Mr.Sun">
<meta property="article:tag" content="Protobuf">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/gods-view/images/master/imageimage-20220818145636178.png">

<link rel="canonical" href="http://example.com/post/638e39a5.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Protobuf入门 | Sun</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sun</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/post/638e39a5.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/blogAvatar.jpeg">
      <meta itemprop="name" content="Mr.Sun">
      <meta itemprop="description" content="澄澈的空与海">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sun">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Protobuf入门
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-19 13:46:17 / 修改时间：17:53:07" itemprop="dateCreated datePublished" datetime="2022-08-19T13:46:17+08:00">2022-08-19</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="什么是Protobuf"><a href="#什么是Protobuf" class="headerlink" title="什么是Protobuf"></a>什么是Protobuf</h1><p>在网络通信和通用数据交换等应用场景中经常使用的技术是 JSON 或 XML，还有一种类型Protobuf。</p>
<p>Protobuf是Protocol Buffers的简称，它是Google出品的性能优异、跨语言、跨平台的序列化库，用于描述一种轻便高效的结构化数据存储格式，并于2008年对外开源。Protobuf可以用于结构化数据串行化，或者说序列化。它的设计非常适用于在网络通讯中的数据载体，很适合做数据存储或 RPC 数据交换格式，它序列化出来的数据量少再加上以 K-V 的方式来存储数据，对消息的版本兼容性非常强，可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。开发者可以通过 ProtoBuf 定义数据结构，然后通过 ProtoBuf 工具生成各种语言版本的数据结构类库，用于操作 ProtoBuf 协议数据</p>
<p>Protobuf是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于（数据）通信协议、数据存储等。</p>
<p>Protocol Buffers 是一种灵活，高效，自动化机制的结构数据序列化方法－可类比 XML，但是比 XML 更小（3 ~ 10倍）、更快（20 ~ 100倍）、更为简单。json、xml都是基于文本格式，protobuf是二进制格式。</p>
<p>Protobuf中最基本的数据单元是message，是类似Go语言中结构体的存在。在message中可以嵌套message或其它的基础数据类型的成员。</p>
<blockquote>
<p>序列化(serialization、marshalling)的过程是指将数据结构或者对象的状态转换成可以存储(比如文件、内存)或者传输的格式(比如网络)。反向操作就是反序列化(deserialization、unmarshalling)的过程。</p>
</blockquote>
<span id="more"></span>
<p><img src="https://raw.githubusercontent.com/gods-view/images/master/imageimage-20220818145636178.png" alt="image-20220818145636178"></p>
<h1 id="定义Message"><a href="#定义Message" class="headerlink" title="定义Message"></a>定义Message</h1><p>使用 ProtoBuf ，首先需要通过 ProtoBuf 语法定义数据结构(消息)，这些定义好的数据结构保存在.proto为后缀的文件中。</p>
<h2 id="字段类型与字段编号"><a href="#字段类型与字段编号" class="headerlink" title="字段类型与字段编号"></a>字段类型与字段编号</h2><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定protobuf的版本，proto3是最新的语法版本，如果省略protocol buffer编译器默认使用proto2语法。他必须是文件中非空非注释行的第一行</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="comment">// package 定义proto的包名，包名可以避免对message 类型之间的名字冲突，同名的Message可以通过package进行区分。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在没有为特定语言定义option xxx_package的时候，它还可以用来生成特定语言的包名，比如Java package, go package。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Request</span> &#123;</span><br><span class="line">  <span class="type">string</span> userId = <span class="number">1</span>;   <span class="comment">// 定义一个string类型的字段，字段名字为userId, 序号为1</span></span><br><span class="line">  <span class="type">int32</span> operation = <span class="number">2</span>;   <span class="comment">// 定义一个int32类型的字段，字段名字为operation, 序号为2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数据结构，message 你可以想象成Go语言中的struct</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Response</span> &#123;</span><br><span class="line">  <span class="type">string</span> data = <span class="number">1</span>;   <span class="comment">// 定义一个string类型的字段，字段名字为data, 序号为1</span></span><br><span class="line">  <span class="type">int32</span> status = <span class="number">2</span>;   <span class="comment">// 定义一个int32类型的字段，字段名字为status, 序号为2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以给字段指定复合类型，包括枚举类型和其他message类型</span></span><br></pre></td></tr></table></figure>

<p>字段是以<code>[ &quot;repeated&quot; ] type fieldName &quot;=&quot; fieldNumber [ &quot;[&quot; fieldOptions &quot;]&quot; ] &quot;;&quot;</code>格式定义的。这个例子是一个简单的例子，采用了<code>type fieldName &quot;=&quot; fieldNumber</code>格式定义的。</p>
<p>比如第一个字段userId, 首先是它的类型<code>string</code>，其次是字段的名称，然后是等号<code>=</code>, 之后是字段的序号，然后是分号。</p>
<p>复杂的结构，前面可以定义为<code>repeated</code>, 序号之后可以定义一些可选项。</p>
<p>这是普通的字段定义，当然还有一些复杂的一些字段定义，比如<code>Oneof</code>、<code>Map</code>、<code>Reserved</code>、<code>enum</code>定义，下一节我们再详细讲。</p>
<blockquote>
<p>在message定义中每个字段都有一个唯一的编号，这些编号被用来在二进制消息体中识别你定义的这些字段，一旦你的message类型被用到后就不应该在修改这些编号了。注意在将message编码成二进制消息体时字段编号1-15将会占用1个字节，16-2047将占用两个字节。所以在一些频繁使用用的message中，你应该总是先使用前面1-15字段编号。</p>
<p>你可以指定的最小编号是1，最大是2E29 - 1（536,870,911）。其中19000到19999是给protocol buffers实现保留的字段标号，定义message时不能使用。</p>
</blockquote>
<h3 id="保留字段"><a href="#保留字段" class="headerlink" title="保留字段"></a>保留字段</h3><p>当你删掉或者注释掉message中的一个字段时，未来其他开发者在更新message定义时就可以重用之前的字段编号。如果他们意外载入了老版本的<code>.proto</code>文件将会导致严重的问题，比如数据损坏、隐私泄露等。一种避免问题发生的方式是指定保留的字段编号和字段名称。如果未来有人用了这些字段标识那么在编译时protocol buffer的编译器会报错。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Foo</span> &#123;</span><br><span class="line">  reserved <span class="number">2</span>, <span class="number">15</span>, <span class="number">9</span> to <span class="number">11</span>;  <span class="comment">// 保留字段</span></span><br><span class="line">  reserved <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Optional的字段和默认值"><a href="#Optional的字段和默认值" class="headerlink" title="Optional的字段和默认值"></a>Optional的字段和默认值</h3><p>如上所述，消息描述中的一个元素可以被标记为“可选的”（optional）。一个格式良好的消息可以包含0个或一个optional的元素。当解 析消息时，如果它不包含optional的元素值，那么解析出来的对象中的对应字段就被置为默认值。默认值可以在消息描述文件中指定。例如，要为 <em>SearchRequest</em>消息的<em>result_per_page</em>字段指定默认值10，在定义消息格式时如下所示：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="type">int32</span> result_per_page = <span class="number">3</span> [default = <span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>如果没有为optional的元素指定默认值，就会使用与特定类型相关的默认值：对string来说，默认值是空字符串。对bool来说，默认值是false。对数值类型来说，默认值是0。对枚举来说，默认值是枚举类型定义中的第一个值。</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>当需要定义一个消息类型的时候，可能想为一个字段指定某“预定义值序列”中的一个值。例如，假设要为每一个SearchRequest消息添加一个 corpus字段，而corpus的值可能是UNIVERSAL，WEB，IMAGES，LOCAL，NEWS，PRODUCTS或VIDEO中的一个。 其实可以很容易地实现这一点：通过向消息定义中添加一个枚举（enum）就可以了。一个enum类型的字段只能用指定的常量集中的一个值作为其值（如果尝 试指定不同的值，解析器就会把它当作一个未知的字段来对待）。在下面的例子中，在消息格式中添加了一个叫做Corpus的枚举类型——它含有所有可能的值 ——以及一个类型为Corpus的字段：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchRequest</span> &#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">int32</span> result_per_page = <span class="number">3</span> [default = <span class="number">10</span>];</span><br><span class="line">  <span class="keyword">enum </span><span class="title class_">Corpus</span> &#123;</span><br><span class="line">    UNIVERSAL = <span class="number">0</span>;</span><br><span class="line">    WEB = <span class="number">1</span>;</span><br><span class="line">    IMAGES = <span class="number">2</span>;</span><br><span class="line">    LOCAL = <span class="number">3</span>;</span><br><span class="line">    NEWS = <span class="number">4</span>;</span><br><span class="line">    PRODUCTS = <span class="number">5</span>;</span><br><span class="line">    VIDEO = <span class="number">6</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">optional</span> Corpus corpus = <span class="number">4</span> [default = UNIVERSAL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以为枚举常量定义别名。 需要设置allow_alias option 为 true, 否则 protocol编译器会产生错误信息。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum </span><span class="title class_">EnumAllowingAlias</span> &#123;</span><br><span class="line">  <span class="keyword">option</span> allow_alias = <span class="literal">true</span>;</span><br><span class="line">  UNKNOWN = <span class="number">0</span>; <span class="comment">// 枚举类型的第一个选项的标识符必须是0，这也是枚举类型的默认值。</span></span><br><span class="line">  STARTED = <span class="number">1</span>;</span><br><span class="line">  RUNNING = <span class="number">1</span>; <span class="comment">// 如果设置allow_alias，允许字段编号重复，RUNNING是STARTED的别名。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum </span><span class="title class_">EnumNotAllowingAlias</span> &#123;</span><br><span class="line">  UNKNOWN2 = <span class="number">0</span>;</span><br><span class="line">  STARTED2 = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// RUNNING = 1;  // Uncommenting this line will cause a compile error inside Google and a warning message outside.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举常量必须在32位整型值的范围内。因为enum值是使用可变编码方式的，对负数不够高效，因此不推荐在enum中使用负数。如上例所示，可以在 一个消息定义的内部或外部定义枚举——这些枚举可以在.proto文件中的任何消息定义里重用。当然也可以在一个消息中声明一个枚举类型，而在另一个不同 的消息中使用它——采用MessageType.EnumType的语法格式。</p>
<p>当对一个使用了枚举的.proto文件运行protocol buffer编译器的时候，生成的代码中将有一个对应的enum（对Java或C++来说），或者一个特殊的EnumDescriptor类（对 Python来说），它被用来在运行时生成的类中创建一系列的整型值符号常量（symbolic constants）。</p>
<p>注意枚举类型的定义采用C++ scoping规则，也就是枚举值是枚举类型的兄弟类型，而不是子类型，所以避免在同一个package定义重名的枚举字段。</p>
<h3 id="Oneof"><a href="#Oneof" class="headerlink" title="Oneof"></a>Oneof</h3><p>如果你有一组字段，同时最多允许这一组中的一个字段出现，就可以使用<code>Oneof</code>定义这一组字段，这有点Union的意思，但是Oneof允许你设置零各值。</p>
<p>因为proto3没有办法区分正常的值是否是设置了还是取得缺省值(比如int64类型字段，如果它的值是0，你无法判断数据是否包含这个字段，因为0几可能是数据中设置的值，也可能是这个字段的零值)，所以你可以通过Oneof取得这个功能，因为Oneof有判断字段是否设置的功能。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">OneofMessage</span> &#123;</span><br><span class="line">    <span class="keyword">oneof</span> test_oneof &#123;</span><br><span class="line">      <span class="type">string</span> name = <span class="number">4</span>;</span><br><span class="line">      <span class="type">int64</span> value = <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>oneof</code>字段不能同时使用<code>repeated</code>。</p>
<h3 id="map类型"><a href="#map类型" class="headerlink" title="map类型"></a>map类型</h3><p>map类型需要设置键和值的类型，格式是<code>&quot;map&quot; &quot;&lt;&quot; keyType &quot;,&quot; type &quot;&gt;&quot; mapName &quot;=&quot; fieldNumber [ &quot;[&quot; fieldOptions &quot;]&quot;</code>。</p>
<p>比如:</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int64</span>,<span class="type">string</span>&gt; values = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><code>map</code>字段不能同时使用<code>repeated</code>。</p>
<h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><p><code>Any</code>字段允许你处理嵌套数据，并不需要它的proto定义。一个<code>Any</code>以bytes呈现序列化的消息，并且包含一个URL作为这个类型的唯一标识和元数据。</p>
<p>为了使用<code>Any</code>类型，你需要引入<code>google/protobuf/any.proto</code>。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/any.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ErrorStatus</span> &#123;</span><br><span class="line">  <span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">repeated</span> google.protobuf.Any details = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Any类型用来替换proto2中的扩展。</p>
<h3 id="使用其他消息类型"><a href="#使用其他消息类型" class="headerlink" title="使用其他消息类型"></a>使用其他消息类型</h3><p>你可以将其他消息类型用作字段类型。例如，假设在每一个SearchResponse消息中包含Result消息，此时可以在相同的.proto文件中定义一个Result消息类型，然后在SearchResponse消息中指定一个Result类型的字段，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchResponse</span> &#123;</span><br><span class="line">  <span class="keyword">repeated</span> Result result = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">string</span> url = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">string</span> title = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="type">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="导入定义"><a href="#导入定义" class="headerlink" title="导入定义"></a>导入定义</h3><p>在上面的例子中，Result消息类型与SearchResponse是定义在同一文件中的。如果想要使用的消息类型已经在其他.proto文件中已经定义过了呢？<br>你可以通过导入（importing）其他.proto文件中的定义来使用它们。要导入其他.proto文件的定义，你需要在你的文件中添加一个导入声明，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;myproject/other_protos.proto&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>默认情况下你只能使用直接导入的.proto文件中的定义. 然而， 有时候你需要移动一个.proto文件到一个新的位置， 可以不直接移动.proto文件， 只需放入一个dummy .proto 文件在老的位置， 然后使用import转向新的位置:</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new.proto</span></span><br><span class="line"><span class="comment">// All definitions are moved here</span></span><br><span class="line"><span class="comment">// old.proto</span></span><br><span class="line"><span class="comment">// This is the proto that all clients are importing.</span></span><br><span class="line"><span class="keyword">import</span> public <span class="string">&quot;new.proto&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;other.proto&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>// client.proto</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;old.proto&quot;</span>;</span><br><span class="line"><span class="comment">// You use definitions from old.proto and new.proto, but not other.proto</span></span><br></pre></td></tr></table></figure>

<p>protocol编译器就会在一系列目录中查找需要被导入的文件，这些目录通过protocol编译器的命令行参数-I/–import_path指定。如果不提供参数，编译器就在其调用目录下查找。</p>
<h3 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h3><p>你可以在其他消息类型中定义、使用消息类型，在下面的例子中，Result消息就定义在SearchResponse消息内，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchResponse</span> &#123;</span><br><span class="line">  <span class="keyword">message </span><span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">string</span> url = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="type">string</span> title = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">repeated</span> Result result = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想在它的父消息类型的外部重用这个消息类型，你需要以Parent.Type的形式使用它，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SomeOtherMessage</span> &#123;</span><br><span class="line">  <span class="keyword">optional</span> SearchResponse.Result result = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，你也可以将消息嵌套任意多层，如：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Outer</span> &#123;                  <span class="comment">// Level 0</span></span><br><span class="line">  <span class="keyword">message </span><span class="title class_">MiddleAA</span> &#123;  <span class="comment">// Level 1</span></span><br><span class="line">    <span class="keyword">message </span><span class="title class_">Inner</span> &#123;   <span class="comment">// Level 2</span></span><br><span class="line">      <span class="keyword">required</span> <span class="type">int64</span> ival = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">optional</span> <span class="type">bool</span>  booly = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">message </span><span class="title class_">MiddleBB</span> &#123;  <span class="comment">// Level 1</span></span><br><span class="line">    <span class="keyword">message </span><span class="title class_">Inner</span> &#123;   <span class="comment">// Level 2</span></span><br><span class="line">      <span class="keyword">required</span> <span class="type">int32</span> ival = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">optional</span> <span class="type">bool</span>  booly = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更新一个消息类型"><a href="#更新一个消息类型" class="headerlink" title="更新一个消息类型"></a>更新一个消息类型</h3><p>==如果一个已有的消息格式已无法满足新的需求——如，要在消息中添加一个额外的字段——但是同时旧版本写的代码仍然可用。不用担心！更新消息而不破坏已有代码是非常简单的。在更新时只要记住以下的规则即可。==</p>
<ul>
<li>不要更改任何已有的字段的数值标识。<br>所添加的任何字段都必须是optional或repeated的。这就意味着任何使用“旧”的消息格式的代码序列化的消息可以被新的代码所解析，因为它们 不会丢掉任何required的元素。应该为这些元素设置合理的默认值，这样新的代码就能够正确地与老代码生成的消息交互了。类似地，新的代码创建的消息 也能被老的代码解析：老的二进制程序在解析的时候只是简单地将新字段忽略。然而，未知的字段是没有被抛弃的。此后，如果消息被序列化，未知的字段会随之一 起被序列化——所以，如果消息传到了新代码那里，则新的字段仍然可用。注意：对Python来说，对未知字段的保留策略是无效的。</li>
<li>非required的字段可以移除——只要它们的标识号在新的消息类型中不再使用（更好的做法可能是重命名那个字段，例如在字段前添加“OBSOLETE_”前缀，那样的话，使用的.proto文件的用户将来就不会无意中重新使用了那些不该使用的标识号）。</li>
<li>一个非required的字段可以转换为一个扩展，反之亦然——只要它的类型和标识号保持不变。</li>
<li>int32, uint32, int64, uint64,和bool是全部兼容的，这意味着可以将这些类型中的一个转换为另外一个，而不会破坏向前、 向后的兼容性。如果解析出来的数字与对应的类型不相符，那么结果就像在C++中对它进行了强制类型转换一样（例如，如果把一个64位数字当作int32来 读取，那么它就会被截断为32位的数字）。</li>
<li>sint32和sint64是互相兼容的，但是它们与其他整数类型不兼容。</li>
<li>string和bytes是兼容的——只要bytes是有效的UTF-8编码。</li>
<li>嵌套消息与bytes是兼容的——只要bytes包含该消息的一个编码过的版本。</li>
<li>fixed32与sfixed32是兼容的，fixed64与sfixed64是兼容的。</li>
</ul>
<h2 id="proto文件编译"><a href="#proto文件编译" class="headerlink" title="proto文件编译"></a>proto文件编译</h2><p>将.proto文件，编译成指定语言类库</p>
<h3 id="安装Protobuf编译器"><a href="#安装Protobuf编译器" class="headerlink" title="安装Protobuf编译器"></a>安装Protobuf编译器</h3><p>protobuf的github发布地址： <a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf/releases">https://github.com/protocolbuffers/protobuf/releases</a></p>
<p>protobuf的编译器叫protoc，在上面的网址中找到最新版本的安装包，下载安装。</p>
<ol>
<li><code>unzip protoc-****-osx-x86_64.zip</code></li>
<li><code>cp -r include/ /usr/local/include/  # 一个&quot;/&quot;都不能少</code></li>
<li><code>cp -r bin/ /usr/local/bin/  # 一个&quot;/&quot;都不能少</code></li>
</ol>
<p>打开cmd，命令窗口执行protoc命令，没有报错的话，就已经安装成功。</p>
<h3 id="安装protoc-gen-go插件"><a href="#安装protoc-gen-go插件" class="headerlink" title="安装protoc-gen-go插件"></a>安装protoc-gen-go插件</h3><p>Protobuf核心的工具集是C++语言开发的，官方的protoc编译器中并不支持Go语言，需要安装一个插件才能生成Go代码。用如下命令安装：</p>
<p><code>go get -u -v github.com/golang/protobuf/protoc-gen-go@v1.3.0 // 指定protoc-gen-go的版本</code></p>
<p>提供了一个<code>protoc-gen-go</code>二进制文件，当编译器调用时传递了<code>--go_out</code>命令行标志时<code>protoc</code>就会使用它。<code>--go_out</code>告诉编译器把Go源代码写到哪里。编译器会为每个<code>.proto</code>文件生成一个单独的源代码文件。</p>
<h3 id="编译对应语言的pb文件"><a href="#编译对应语言的pb文件" class="headerlink" title="编译对应语言的pb文件"></a>编译对应语言的pb文件</h3><p>在当前的目录下执行<code>protoc -I=. -I/usr/local/include -I=$(GOPATH)/src --go_out=. simple.proto</code>, 可以将这个proto编译成Go的代码，因为这里我们使用了<code>go_out</code>输出格式。</p>
<p><code>-I</code>指定protoc的搜索import的proto的文件夹。在<code>MacOS</code>操作系统中protobuf把一些扩展的proto放在了<code>/usr/local/include</code>对应的文件夹中，一些第三方的Go库放在了gopath对应的包下，所以这里都把它们加上了。对于这个简单的例子，实际是不需要的。</p>
<p><code>cpp_out</code>用来生成C++代码，<code>java_out</code>产生Java代码，<code>python_out</code>产生python代码，类似地还有<code>csharp_out</code>、<code>objc_out</code>、<code>ruby_out</code>、<code>php_out</code>等参数。</p>
<p>一些第三方的插件也会定义自己的输出插件，比如<code>gofast_out</code>使用gogo库生成代码， <code>rust_out</code>产生rust代码。</p>
<p>生成的代码我们指定放在本地文件夹中(<code>--go_out=.</code>)。</p>
<p>输出文件的名称是通过获取.proto文件的名称并进行两处更改来计算的：</p>
<ul>
<li>生成文件的扩展名是<code>.pb.go</code>。比如说<code>user.proto</code>编译后会得到<code>user.pb.go</code>。</li>
<li>proto路径（使用<code>--proto_path</code>或<code>-I</code>命令行标志指定）将替换为输出路径（使用<code>--go_out</code>标志指定）。</li>
</ul>
<p>当你运行如下编译命令时：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=src --go_out=build/gen src/foo.proto src/bar/baz.proto</span><br></pre></td></tr></table></figure>

<p>编译器会读取文件<code>src/foo.proto</code>和<code>src/bar/baz.proto</code>，这将会生成两个输出文件<code>build/gen/foo.pb.go</code>和<code>build/gen/bar/baz.pb.go</code></p>
<p>如果有必要，编译器会自动生成<code>build/gen/bar</code>目录，但是他不能创建<code>build</code>或者<code>build/gen</code>目录，这两个必须是已经存在的目录。</p>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>如果一个<code>.proto</code>文件中有包声明，生成的源代码将会使用它来作为Go的包名，如果<code>.proto</code>的包名中有<code>.</code> 在Go包名中会将<code>.</code>转换为<code>_</code>。举例来说<code>proto</code>包名<code>example.high_score</code>将会生成Go包名<code>example_high_score</code>。</p>
<p>在<code>.proto</code>文件中可以使用option <code>go_package</code>指令来覆盖上面默认生成Go包名的规则。比如说包含如下指令的一个<code>.proto</code>文件</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> example.high_score;</span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;hs&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>生成的Go源代码的包名是<code>hs</code>。</p>
<p>如果一个<code>.proto</code>文件中不包含package声明，生成的源代码将会使用<code>.proto</code>文件的文件名(去掉扩展名)作为Go包名，<code>.</code>会被首先转换为<code>_</code>。举例来说一个名为<code>high.score.proto</code>不包含pack声明的文件将会生成文件<code>high.score.pb.go</code>，他的Go包名是<code>high_score</code>。</p>
<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>一个简单的消息声明：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Foo</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>protocol buffer编译器将会生成一个名为<code>Foo</code>的结构体，实现了<code>proto.Message</code>接口的<code>Foo</code>类型的指针</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type Foo struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置proto为默认值</span></span><br><span class="line">func (m *Foo) Reset()         &#123; *m = Foo&#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String 返回proto的字符串表示</span></span><br><span class="line">func (m *Foo) String() <span class="type">string</span> &#123; return proto.CompactTextString(m) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProtoMessage作为一个tag 确保其他人不会意外的实现</span></span><br><span class="line"><span class="comment">// proto.Message 接口.</span></span><br><span class="line">func (*Foo) ProtoMessage()    &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内嵌的消息"><a href="#内嵌的消息" class="headerlink" title="内嵌的消息"></a>内嵌的消息</h3><p>一个message可以声明在其他message的内部。比如说：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">message </span><span class="title class_">Bar</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况，编译器会生成两个结构体：<code>Foo</code>和<code>Foo_Bar</code>。</p>
<h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p>编译器会为每个在message中定义的字段生成一个Go结构体的字段，字段的确切性质取决于它的类型以及它是<code>singular</code>，<code>repeated</code>，<code>map</code>还是<code>oneof</code>字段。</p>
<p>注意生成的Go结构体的字段将始终使用驼峰命名，即使在<code>.proto</code>文件中消息字段用的是小写加下划线（应该这样）。大小写转换的原理如下：</p>
<ul>
<li>首字母会大些，如果message中字段的第一个字符是<code>_</code>，它将被替换为X。</li>
<li>如果内部下划线后跟小写字母，则删除下划线，并将后面跟随的字母大写。</li>
</ul>
<p>因此，proto字段<code>foo_bar_baz</code>在Go中变成<code>FooBarBaz</code>， <code>_my_field_name_2</code>变为<code>XMyFieldName_2</code>。</p>
<h3 id="单一标量字段"><a href="#单一标量字段" class="headerlink" title="单一标量字段"></a>单一标量字段</h3><p>对于字段定义：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32</span> foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>编译器将生成一个带有名为Foo的int32字段和一个访问器方法GetFoo（）的结构，该方法返回Foo中的int32值或该字段的零值（如果字段未设置（数值型零值为0，字符串为空字符串））。</p>
<h3 id="单一message字段"><a href="#单一message字段" class="headerlink" title="单一message字段"></a>单一message字段</h3><p>给出如下消息类型</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Bar</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>对于一个有<code>Bar</code>类型字段的消息：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proto3</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Baz</span> &#123;</span><br><span class="line">  Bar foo = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器将会生成一个Go结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Baz <span class="keyword">struct</span> &#123;</span><br><span class="line">        Foo *Bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息类型的字段可以设置为nil，这意味着该字段未设置，有效清除该字段。这不等同于将值设置为消息结构体的“空”实例。</p>
<p>编译器还生成一个<code>func（m * Baz）GetFoo（）* Bar</code>辅助函数。这让不在中间检查nil值进行链式调用成为可能。</p>
<h3 id="可重复字段"><a href="#可重复字段" class="headerlink" title="可重复字段"></a>可重复字段</h3><p>每个重复的字段在Go中的结构中生成一个T类型的slice，其中T是字段的元素类型。对于带有重复字段的此消息：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Baz</span> &#123;</span><br><span class="line">  <span class="keyword">repeated</span> Bar foo = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会生成如下结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Baz <span class="keyword">struct</span> &#123;</span><br><span class="line">        Foo  []*Bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，对于字段定义<code>repeated bytes foo = 1;</code>编译器将会生成一个带有类型为<code>[][]byte</code>名为<code>Foo</code>的字段的Go结构体。对于可重复的枚举<code>repeated MyEnum bar = 2;</code>，编译器会生成带有类型为<code>[]MyEnum</code>名为<code>Bar</code>的字段的Go结构体。</p>
<h3 id="映射字段"><a href="#映射字段" class="headerlink" title="映射字段"></a>映射字段</h3><p>每个映射字段会在Go的结构体中生成一个<code>map[TKey]TValue</code>类型的字段，其中<code>TKey</code>是字段的键类型<code>TValue</code>是字段的值类型。对于下面这个消息定义：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Bar</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Baz</span> &#123;</span><br><span class="line">  map&lt;<span class="type">string</span>, Bar&gt; foo = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器生成Go结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Baz <span class="keyword">struct</span> &#123;</span><br><span class="line">        Foo <span class="keyword">map</span>[<span class="type">string</span>]*Bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举-1"><a href="#枚举-1" class="headerlink" title="枚举"></a>枚举</h2><p>给出如下枚举</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchRequest</span> &#123;</span><br><span class="line">  <span class="keyword">enum </span><span class="title class_">Corpus</span> &#123;</span><br><span class="line">    UNIVERSAL = <span class="number">0</span>;</span><br><span class="line">    WEB = <span class="number">1</span>;</span><br><span class="line">    IMAGES = <span class="number">2</span>;</span><br><span class="line">    LOCAL = <span class="number">3</span>;</span><br><span class="line">    NEWS = <span class="number">4</span>;</span><br><span class="line">    PRODUCTS = <span class="number">5</span>;</span><br><span class="line">    VIDEO = <span class="number">6</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Corpus corpus = <span class="number">1</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器将会生成一个枚举类型和一系列该类型的常量。</p>
<p>对于消息中的枚举（像上面那样），类型名字以消息名开头</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SearchRequest_Corpus <span class="type">int32</span></span><br></pre></td></tr></table></figure>

<p>对于包级别的枚举：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .proto</span></span><br><span class="line"><span class="keyword">enum </span><span class="title class_">Foo</span> &#123;</span><br><span class="line">  DEFAULT_BAR = <span class="number">0</span>;</span><br><span class="line">  BAR_BELLS = <span class="number">1</span>;</span><br><span class="line">  BAR_B_CUE = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 中的类型不会对proto中的枚举名称进行修改：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="type">int32</span></span><br></pre></td></tr></table></figure>

<p>此类型具有<code>String()</code>方法，该方法返回给定值的名称。</p>
<p><code>Enum()</code>方法使用给定值初始化新分配的内存并返回相应的指针：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Foo)</span></span> Enum() *Foo</span><br></pre></td></tr></table></figure>

<p>编译器为枚举中的每个值生成一个常量。对于消息中的枚举，常量以消息的名称开头：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        SearchRequest_UNIVERSAL SearchRequest_Corpus = <span class="number">0</span></span><br><span class="line">        SearchRequest_WEB       SearchRequest_Corpus = <span class="number">1</span></span><br><span class="line">        SearchRequest_IMAGES    SearchRequest_Corpus = <span class="number">2</span></span><br><span class="line">        SearchRequest_LOCAL     SearchRequest_Corpus = <span class="number">3</span></span><br><span class="line">        SearchRequest_NEWS      SearchRequest_Corpus = <span class="number">4</span></span><br><span class="line">        SearchRequest_PRODUCTS  SearchRequest_Corpus = <span class="number">5</span></span><br><span class="line">        SearchRequest_VIDEO     SearchRequest_Corpus = <span class="number">6</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>对于包级别的枚举，常量以枚举名称开头:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        Foo_DEFAULT_BAR Foo = <span class="number">0</span></span><br><span class="line">        Foo_BAR_BELLS   Foo = <span class="number">1</span></span><br><span class="line">        Foo_BAR_B_CUE   Foo = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>protobuf编译器还生成从整数值到字符串名称的映射以及从名称到值的映射：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo_name = <span class="keyword">map</span>[<span class="type">int32</span>]<span class="type">string</span>&#123;</span><br><span class="line">        <span class="number">0</span>: <span class="string">&quot;DEFAULT_BAR&quot;</span>,</span><br><span class="line">        <span class="number">1</span>: <span class="string">&quot;BAR_BELLS&quot;</span>,</span><br><span class="line">        <span class="number">2</span>: <span class="string">&quot;BAR_B_CUE&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Foo_value = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int32</span>&#123;</span><br><span class="line">        <span class="string">&quot;DEFAULT_BAR&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;BAR_BELLS&quot;</span>:   <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;BAR_B_CUE&quot;</span>:   <span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，<code>.proto</code>语言允许多个枚举符号具有相同的数值。具有相同数值的符号是同义词。这些在Go中以完全相同的方式表示，多个名称对应于相同的数值。反向映射包含数字值的单个条目，数值映射到出现在<code>proto</code>文件中首先出现的名称。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Mr.Sun
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/post/638e39a5.html" title="Protobuf入门">http://example.com/post/638e39a5.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Protobuf/" rel="tag"><i class="fa fa-tag"></i> Protobuf</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/post/539388a9.html" rel="prev" title="go基础数据类型">
      <i class="fa fa-chevron-left"></i> go基础数据类型
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFProtobuf"><span class="nav-number">1.</span> <span class="nav-text">什么是Protobuf</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89Message"><span class="nav-number">2.</span> <span class="nav-text">定义Message</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AD%97%E6%AE%B5%E7%BC%96%E5%8F%B7"><span class="nav-number">2.1.</span> <span class="nav-text">字段类型与字段编号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E7%95%99%E5%AD%97%E6%AE%B5"><span class="nav-number">2.1.1.</span> <span class="nav-text">保留字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Optional%E7%9A%84%E5%AD%97%E6%AE%B5%E5%92%8C%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">2.1.2.</span> <span class="nav-text">Optional的字段和默认值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE"><span class="nav-number">2.1.3.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Oneof"><span class="nav-number">2.1.4.</span> <span class="nav-text">Oneof</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.5.</span> <span class="nav-text">map类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Any"><span class="nav-number">2.1.6.</span> <span class="nav-text">Any</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%85%B6%E4%BB%96%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.7.</span> <span class="nav-text">使用其他消息类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E5%AE%9A%E4%B9%89"><span class="nav-number">2.1.8.</span> <span class="nav-text">导入定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.9.</span> <span class="nav-text">嵌套类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.10.</span> <span class="nav-text">更新一个消息类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#proto%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="nav-number">2.2.</span> <span class="nav-text">proto文件编译</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85Protobuf%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">2.2.1.</span> <span class="nav-text">安装Protobuf编译器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85protoc-gen-go%E6%8F%92%E4%BB%B6"><span class="nav-number">2.2.2.</span> <span class="nav-text">安装protoc-gen-go插件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%AF%B9%E5%BA%94%E8%AF%AD%E8%A8%80%E7%9A%84pb%E6%96%87%E4%BB%B6"><span class="nav-number">2.2.3.</span> <span class="nav-text">编译对应语言的pb文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85"><span class="nav-number">2.2.4.</span> <span class="nav-text">包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF"><span class="nav-number">2.2.5.</span> <span class="nav-text">消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%B5%8C%E7%9A%84%E6%B6%88%E6%81%AF"><span class="nav-number">2.2.6.</span> <span class="nav-text">内嵌的消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5"><span class="nav-number">2.2.7.</span> <span class="nav-text">字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%B8%80%E6%A0%87%E9%87%8F%E5%AD%97%E6%AE%B5"><span class="nav-number">2.2.8.</span> <span class="nav-text">单一标量字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%B8%80message%E5%AD%97%E6%AE%B5"><span class="nav-number">2.2.9.</span> <span class="nav-text">单一message字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AE%B5"><span class="nav-number">2.2.10.</span> <span class="nav-text">可重复字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E5%AD%97%E6%AE%B5"><span class="nav-number">2.2.11.</span> <span class="nav-text">映射字段</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE-1"><span class="nav-number">2.3.</span> <span class="nav-text">枚举</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mr.Sun"
      src="/images/blogAvatar.jpeg">
  <p class="site-author-name" itemprop="name">Mr.Sun</p>
  <div class="site-description" itemprop="description">澄澈的空与海</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/gods-view" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gods-view" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/gods.views619@gmail.com" title="E-Mail → gods.views619@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.Sun</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">20k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">19 分钟</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
