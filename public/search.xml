<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>go基础数据类型</title>
    <url>/post/539388a9.html</url>
    <content><![CDATA[<h2 id="1-结构体和指针"><a href="#1-结构体和指针" class="headerlink" title="1. 结构体和指针"></a>1. 结构体和指针</h2><p>与C相同而与Java不同的是，Go语言让程序员决定何时使用指针。举例来说，这种类型定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123; X, Y <span class="type">int</span> &#125;</span><br></pre></td></tr></table></figure>

<p>先来定义一个简单的struct类型，名为Point，表示内存中两个相邻的整数。</p>
<p><img src="https://raw.githubusercontent.com/gods-view/images/master/imageimage-20201202173141496.png" alt="image-20201202173141496"></p>
<p><code>Point&#123;10,20&#125;</code>表示一个已初始化的Point类型。对它进行取地址表示一个指向刚刚分配和初始化的Point类型的指针。前者在内存中是两个词，而后者是一个指向两个词的指针。</p>
<p>结构体的域在内存中是紧挨着排列的。</p>
<span id="more"></span>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Rect1 <span class="keyword">struct</span> &#123; Min, Max Point &#125;</span><br><span class="line"><span class="keyword">type</span> Rect2 <span class="keyword">struct</span> &#123; Min, Max *Point &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/gods-view/images/master/imageimage-20201202173244021.png" alt="image-20201202173244021"></p>
<p>Rect1是一个具有两个Point类型属性的结构体，由在一行的两个Point–四个int代表。Rect2是一个具有两个<code>*Point</code>类型属性的结构体，由两个*Point表示。</p>
<p>使用过C的程序员可能对<code>Point</code>和<code>*Point</code>的不同毫不见怪，但用惯Java或Python的程序员们可能就不那么轻松了。Go语言给了程序员基本内存层面的控制，由此提供了诸多能力，如控制给定数据结构集合的总大小、内存分配的次数、内存访问模式以及建立优秀系统的所有要点。</p>
<h2 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2. 字符串"></a>2. 字符串</h2><p>有了前面的准备，我们就可以开始研究更有趣的数据类型了。</p>
<p><img src="https://raw.githubusercontent.com/gods-view/images/master/imageimage-20201202173305713.png" alt="image-20201202173305713"></p>
<p>（灰色的箭头表示已经实现的但不能直接可见的指针）</p>
<p>字符串在Go语言内存模型中用一个2字长的数据结构表示。它包含一个指向字符串存储数据的指针和一个长度数据。因为string类型是不可变的，对于多字符串共享同一个存储数据是安全的。切分操作<code>str[i:j]</code>会得到一个新的2字长结构，一个可能不同的但仍指向同一个字节序列(即上文说的存储数据)的指针和长度数据。这意味着字符串切分可以在不涉及内存分配或复制操作。这使得字符串切分的效率等同于传递下标。</p>
<p>（说句题外话，在Java和其他语言里有一个有名的“疑难杂症”：在你分割字符串并保存时，对于源字符串的引用在内存中仍然保存着完整的原始字符串–即使只有一小部分仍被需要，Go也有这个“毛病”。另一方面，我们努力但又失败了的是，让字符串分割操作变得昂贵–包含一次分配和一次复制。在大多数程序中都避免了这么做。）</p>
<h2 id="3-slice"><a href="#3-slice" class="headerlink" title="3. slice"></a>3. slice</h2><blockquote>
<p>切片拥有 <strong>长度</strong> 和 <strong>容量</strong>。</p>
<p>切片的长度就是它所包含的元素个数。</p>
<p>切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。</p>
<p>切片 s 的长度和容量可通过表达式<code> len(s)</code> 和 <code>cap(s)</code> 来获取。</p>
</blockquote>
<hr>
<p>一个slice是一个数组某个部分的引用。在内存中，它是一个包含3个域的结构体：指向slice中第一个元素的指针，slice的长度，以及slice的容量。长度是下标操作的上界，如x[i]中i必须小于长度。容量是分割操作的上界，如x[i:j]中j不能大于容量。</p>
<p><img src="https://raw.githubusercontent.com/gods-view/images/master/image20201201174947.png"></p>
<p>数组的slice并不会实际复制一份数据，它只是创建一个新的数据结构，包含了另外的一个指针，一个长度和一个容量数据。 如同分割一个字符串，分割数组也不涉及复制操作：它只是新建了一个结构来放置一个不同的指针，长度和容量。在例子中，对[]int{2,3,5,7,11}求值操作会创建一个包含五个值的数组，并设置x的属性来描述这个数组。分割表达式x[1:3]并不分配更多的数据：它只是写了一个新的slice结构的属性来引用相同的存储数据。在例子中，长度为2–只有y[0]和y[1]是有效的索引，但是容量为4–y[0:4]是一个有效的分割表达式。</p>
<p>由于slice是不同于指针的多字长结构，分割操作并不需要分配内存，甚至没有通常被保存在堆中的slice头部。这种表示方法使slice操作和在C中传递指针、长度对一样廉价。Go语言最初使用一个指向以上结构的指针来表示slice，但是这样做意味着每个slice操作都会分配一块新的内存对象。即使使用了快速的分配器，还是给垃圾收集器制造了很多没有必要的工作。移除间接引用及分配操作可以让slice足够廉价，以避免传递显式索引。</p>
<h2 id="4-map的实现"><a href="#4-map的实现" class="headerlink" title="4. map的实现"></a>4. map的实现</h2><p>Go中的map在底层是用哈希表实现的，你可以在 $GOROOT/src/pkg/runtime/hashmap.goc 找到它的实现。</p>
<h3 id="4-1-数据结构"><a href="#4-1-数据结构" class="headerlink" title="4.1 数据结构"></a>4.1 数据结构</h3><p>哈希表的数据结构中一些关键的域如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Hmap</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8</span>   B;    <span class="comment">// 可以容纳2^B个项</span></span><br><span class="line">    <span class="type">uint16</span>  bucketsize;   <span class="comment">// 每个桶的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>    *buckets;     <span class="comment">// 2^B个Buckets的数组</span></span><br><span class="line">    <span class="type">byte</span>    *oldbuckets;  <span class="comment">// 前一个buckets，只有当正在扩容时才不为空</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面给出的结构体只是Hmap的部分的域。需要注意到的是，这里直接使用的是Bucket的数组，而不是Bucket*指针的数组。这意味着，第一个Bucket和后面溢出链的Bucket分配有些不同。第一个Bucket是用的一段连续的内存空间，而后面溢出链的Bucket的空间是使用mallocgc分配的。</p>
<p>这个hash结构使用的是一个可扩展哈希的算法，由hash值mod当前hash表大小决定某一个值属于哪个桶，而hash表大小是2的指数，即上面结构体中的2^B。每次扩容，会增大到上次大小的两倍。结构体中有一个buckets和一个oldbuckets是用来实现增量扩容的。正常情况下直接使用buckets，而oldbuckets为空。如果当前哈希表正在扩容中，则oldbuckets不为空，并且buckets大小是oldbuckets大小的两倍。</p>
<p>具体的Bucket结构如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Bucket</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8</span>  tophash[BUCKETSIZE]; <span class="comment">// hash值的高8位....低位从bucket的array定位到bucket</span></span><br><span class="line">    Bucket *overflow;           <span class="comment">// 溢出桶链表，如果有</span></span><br><span class="line">    <span class="type">byte</span>   data[<span class="number">1</span>];             <span class="comment">// BUCKETSIZE keys followed by BUCKETSIZE values</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中BUCKETSIZE是用宏定义的8，每个bucket中存放最多8个key/value对, 如果多于8个，那么会申请一个新的bucket，并将它与之前的bucket链起来。</p>
<p>按key的类型采用相应的hash算法得到key的hash值。将hash值的低位当作Hmap结构体中buckets数组的index，找到key所在的bucket。将hash的高8位存储在了bucket的tophash中。<strong>注意，这里高8位不是用来当作key/value在bucket内部的offset的，而是作为一个主键，在查找时对tophash数组的每一项进行顺序匹配的</strong>。先比较hash值高位与bucket的tophash[i]是否相等，如果相等则再比较bucket的第i个的key与所给的key是否相等。如果相等，则返回其对应的value，反之，在overflow buckets中按照上述方法继续寻找。</p>
<p>整个hash的存储如下图所示(临时先采用了XX同学画的图，这个图有点问题)：</p>
<p><img src="https://raw.githubusercontent.com/gods-view/images/master/imageimage-20201202173456850.png" alt="image-20201202173456850"></p>
<p>图2.2 HMap的存储结构</p>
<p>注意一个细节是Bucket中key/value的放置顺序，是将keys放在一起，values放在一起，为什么不将key和对应的value放在一起呢？如果那么做，存储结构将变成key1/value1/key2/value2… 设想如果是这样的一个map[int64]int8，考虑到字节对齐，会浪费很多存储空间。不得不说通过上述的一个小细节，可以看出Go在设计上的深思熟虑。</p>
<h3 id="4-2-增量扩容"><a href="#4-2-增量扩容" class="headerlink" title="4.2 增量扩容"></a>4.2 增量扩容</h3><p>大家都知道哈希表表就是以空间换时间，访问速度是直接跟填充因子相关的，所以当哈希表太满之后就需要进行扩容。</p>
<p>如果扩容前的哈希表大小为2^B，扩容之后的大小为2^(B+1)，每次扩容都变为原来大小的两倍，哈希表大小始终为2的指数倍，则有(hash mod 2^B)等价于(hash &amp; (2^B-1))。这样可以简化运算，避免了取余操作。</p>
<p>假设扩容之前容量为X，扩容之后容量为Y，对于某个哈希值hash，一般情况下(hash mod X)不等于(hash mod Y)，所以扩容之后要重新计算每一项在哈希表中的新位置。当hash表扩容之后，需要将那些旧的pair重新哈希到新的table上(源代码中称之为evacuate)， 这个工作并没有在扩容之后一次性完成，而是逐步的完成（在insert和remove时每次搬移1-2个pair），Go语言使用的是增量扩容。</p>
<p>为什么会增量扩容呢？主要是缩短map容器的响应时间。假如我们直接将map用作某个响应实时性要求非常高的web应用存储，如果不采用增量扩容，当map里面存储的元素很多之后，扩容时系统就会卡往，导致较长一段时间内无法响应请求。不过增量扩容本质上还是将总的扩容时间分摊到了每一次哈希操作上面。</p>
<p>扩容会建立一个大小是原来2倍的新的表，将旧的bucket搬到新的表中之后，并不会将旧的bucket从oldbucket中删除，而是加上一个已删除的标记。</p>
<p>正是由于这个工作是逐渐完成的，这样就会导致一部分数据在old table中，一部分在new table中， 所以对于hash table的insert, remove, lookup操作的处理逻辑产生影响。只有当所有的bucket都从旧表移到新表之后，才会将oldbucket释放掉。</p>
<p>扩容的填充因子是多少呢？如果grow的太频繁，会造成空间的利用率很低， 如果很久才grow，会形成很多的overflow buckets，查找的效率也会下降。 这个平衡点如何选取呢(在go中，这个平衡点是有一个宏控制的(#define LOAD 6.5), 它的意思是这样的，如果table中元素的个数大于table中能容纳的元素的个数， 那么就触发一次grow动作。那么这个6.5是怎么得到的呢？原来这个值来源于作者的一个测试程序，遗憾的是没能找到相关的源码，不过作者给出了测试的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       LOAD    %overflow  bytes/entry     hitprobe    missprobe</span><br><span class="line">       4.00         2.13        20.77         3.00         4.00</span><br><span class="line">       4.50         4.05        17.30         3.25         4.50</span><br><span class="line">       5.00         6.85        14.77         3.50         5.00</span><br><span class="line">       5.50        10.55        12.94         3.75         5.50</span><br><span class="line">       6.00        15.27        11.67         4.00         6.00</span><br><span class="line">       6.50        20.90        10.79         4.25         6.50</span><br><span class="line">       7.00        27.14        10.15         4.50         7.00</span><br><span class="line">       7.50        34.03         9.73         4.75         7.50</span><br><span class="line">       8.00        41.10         9.40         5.00         8.00</span><br><span class="line"></span><br><span class="line">%overflow   = percentage of buckets which have an overflow bucket</span><br><span class="line">bytes/entry = overhead bytes used per key/value pair</span><br><span class="line">hitprobe    = # of entries to check when looking up a present key</span><br><span class="line">missprobe   = # of entries to check when looking up an absent key</span><br></pre></td></tr></table></figure>

<p>可以看出作者取了一个相对适中的值。</p>
<h3 id="4-3-查找过程"><a href="#4-3-查找过程" class="headerlink" title="4.3 查找过程"></a>4.3 查找过程</h3><ol>
<li>根据key计算出hash值。</li>
<li>如果存在old table, 首先在old table中查找，如果找到的bucket已经evacuated，转到步骤3。 反之，返回其对应的value。</li>
<li>在new table中查找对应的value。</li>
</ol>
<p>这里一个细节需要注意一下。不认真看可能会以为低位用于定位bucket在数组的index，那么高位就是用于key/valule在bucket内部的offset。事实上高8位不是用作offset的，而是用于加快key的比较的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do &#123; //对每个桶b</span><br><span class="line">    //依次比较桶内的每一项存放的tophash与所求的hash值高位是否相等</span><br><span class="line">    for(i = 0, k = b-&gt;data, v = k + h-&gt;keysize * BUCKETSIZE; i &lt; BUCKETSIZE; i++, k += h-&gt;keysize, v += h-&gt;valuesize) &#123;</span><br><span class="line">        if(b-&gt;tophash[i] == top) &#123; </span><br><span class="line">            k2 = IK(h, k);</span><br><span class="line">            t-&gt;key-&gt;alg-&gt;equal(&amp;eq, t-&gt;key-&gt;size, key, k2);</span><br><span class="line">            if(eq) &#123; //相等的情况下再去做key比较...</span><br><span class="line">                *keyp = k2;</span><br><span class="line">                return IV(h, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    b = b-&gt;overflow; //b设置为它的下一下溢出链</span><br><span class="line">&#125; while(b != nil);</span><br></pre></td></tr></table></figure>

<h3 id="4-4-插入过程分析"><a href="#4-4-插入过程分析" class="headerlink" title="4.4 插入过程分析"></a>4.4 插入过程分析</h3><ol>
<li>根据key算出hash值，进而得出对应的bucket。</li>
<li>如果bucket在old table中，将其重新散列到new table中。</li>
<li>在bucket中，查找空闲的位置，如果已经存在需要插入的key，更新其对应的value。</li>
<li>根据table中元素的个数，判断是否grow table。</li>
<li>如果对应的bucket已经full，重新申请新的bucket作为overbucket。</li>
<li>将key/value pair插入到bucket中。</li>
</ol>
<p>这里也有几个细节需要注意一下。</p>
<p>在扩容过程中，oldbucket是被冻结的，查找时会在oldbucket中查找，但不会在oldbucket中插入数据。如果在oldbucket是找到了相应的key，做法是将它迁移到新bucket后加入evalucated标记。并且还会额外的迁移另一个pair。</p>
<p>然后就是只要在某个bucket中找到第一个空位，就会将key/value插入到这个位置。也就是位置位于bucket前面的会覆盖后面的(类似于存储系统设计中做删除时的常用的技巧之一，直接用新数据追加方式写，新版本数据覆盖老版本数据)。找到了相同的key或者找到第一个空位就可以结束遍历了。不过这也意味着做删除时必须完全的遍历bucket所有溢出链，将所有的相同key数据都删除。所以目前map的设计是为插入而优化的，删除效率会比插入低一些。</p>
<h3 id="4-5-map设计中的性能优化"><a href="#4-5-map设计中的性能优化" class="headerlink" title="4.5 map设计中的性能优化"></a>4.5 map设计中的性能优化</h3><p>读完map源代码发现作者还是做了很多设计上的选择的。本人水平有限，谈不上优劣的点评，这里只是拿出来与读者分享。</p>
<p>HMap中是Bucket的数组，而不是Bucket指针的数组。好的方面是可以一次分配较大内存，减少了分配次数，避免多次调用mallocgc。但相应的缺点，其一是可扩展哈希的算法并没有发生作用，扩容时会造成对整个数组的值拷贝(如果实现上用Bucket指针的数组就是指针拷贝了，代价小很多)。其二是首个bucket与后面产生了不一致性。这个会使删除逻辑变得复杂一点。比如删除后面的溢出链可以直接删除，而对于首个bucket，要等到evalucated完毕后，整个oldbucket删除时进行。</p>
<p>没有重用设freelist重用删除的结点。作者把这个加了一个TODO的注释，不过想了一下觉得这个做的意义不大。因为一方面，bucket大小并不一致，重用比较麻烦。另一方面，下层存储已经做过内存池的实现了，所以这里不做重用也会在内存分配那一层被重用的，</p>
<p>bucket直接key/value和间接key/value优化。这个优化做得蛮好的。注意看代码会发现，如果key或value小于128字节，则它们的值是直接使用的bucket作为存储的。否则bucket中存储的是指向实际key/value数据的指针，</p>
<p>bucket存8个key/value对。查找时进行顺序比较。第一次发现高位居然不是用作offset，而是用于加快比较的。定位到bucket之后，居然是一个顺序比较的查找过程。后面仔细想了想，觉得还行。由于bucket只有8个，顺序比较下来也不算过分。仍然是O(1)只不过前面系数大一点点罢了。相当于hash到一个小范围之后，在这个小范围内顺序查找。</p>
<p>插入删除的优化。前面已经提过了，插入只要找到相同的key或者第一个空位，bucket中如果存在一个以上的相同key，前面覆盖后面的(只是如果，实际上不会发生)。而删除就需要遍历完所有bucket溢出链了。这样map的设计就是为插入优化的。考虑到一般的应用场景，这个应该算是很合理的。</p>
<h2 id="5-nil类型"><a href="#5-nil类型" class="headerlink" title="5. nil类型"></a>5. nil类型</h2><p>什么？nil是一种数据结构么？为什么会讲到它，没搞错吧？没搞错。不仅仅是Go语言中，每门语言中nil都是非常重要的，它代表的是空值的语义。</p>
<p>在不同语言中，表示空这个概念都有细微不同。比如在scheme语言(一种lisp方言)中，nil是true的！而在ruby语言中，一切都是对象，连nil也是一个对象！在C中NULL跟0是等价的。</p>
<p>按照Go语言规范，任何类型在未初始化时都对应一个零值：布尔类型是false，整型是0，字符串是””，而指针，函数，interface，slice，channel和map的零值都是nil。</p>
<h3 id="5-1-interface"><a href="#5-1-interface" class="headerlink" title="5.1 interface"></a>5.1 interface</h3><p>一个interface在没有进行初始化时，对应的值是nil。也就是说<code>var v interface&#123;&#125;</code>，</p>
<p>此时v就是一个nil。在底层存储上，它是一个空指针。与之不同的情况是，interface值为空。比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v *T</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">i = v</span><br></pre></td></tr></table></figure>

<p>此时i是一个interface，它的值是nil，但它自身不为nil。</p>
<p>Go中的error其实就是一个实现了Error方法的接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，我们可以自定义一个error：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Error <span class="keyword">struct</span> &#123;</span><br><span class="line">    errCode <span class="type">uint8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Error)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> e.errCode &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;file not found&quot;</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;time out&quot;</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;permission denied&quot;</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;unknown error&quot;</span></span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们这样使用它：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> e *Error</span><br><span class="line">checkError(e)</span><br></pre></td></tr></table></figure>

<p>e是nil的，但是当我们checkError时就会panic。请读者思考一下为什么？</p>
<p>总之，interface跟C语言的指针一样非常灵活，关于空的语义，也跟空指针一样容易困扰新手的，需要注意。</p>
<h3 id="5-2-string和slice"><a href="#5-2-string和slice" class="headerlink" title="5.2 string和slice"></a>5.2 string和slice</h3><p>string的空值是””，它是不能跟nil比较的。即使是空的string，它的大小也是两个机器字长的。slice也类似，它的空值并不是一个空指针，而是结构体中的指针域为空，空的slice的大小也是三个机器字长的。</p>
<h3 id="5-3-channel和map"><a href="#5-3-channel和map" class="headerlink" title="5.3 channel和map"></a>5.3 channel和map</h3><p>channel跟string或slice有些不同，它在栈上只是一个指针，实际的数据都是由指针所指向的堆上面。</p>
<p>跟channel相关的操作有：初始化/读/写/关闭。channel未初始化值就是nil，未初始化的channel是不能使用的。下面是一些操作规则：</p>
<ul>
<li>读或者写一个nil的channel的操作会永远阻塞。</li>
<li>读一个关闭的channel会立刻返回一个channel元素类型的零值。</li>
<li>写一个关闭的channel会导致panic。</li>
</ul>
<p>map也是指针，实际数据在堆中，未初始化的值是nil。</p>
]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/post/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Protobuf入门</title>
    <url>/post/638e39a5.html</url>
    <content><![CDATA[<h1 id="什么是Protobuf"><a href="#什么是Protobuf" class="headerlink" title="什么是Protobuf"></a>什么是Protobuf</h1><p>在网络通信和通用数据交换等应用场景中经常使用的技术是 JSON 或 XML，还有一种类型Protobuf。</p>
<p>Protobuf是Protocol Buffers的简称，它是Google出品的性能优异、跨语言、跨平台的序列化库，用于描述一种轻便高效的结构化数据存储格式，并于2008年对外开源。Protobuf可以用于结构化数据串行化，或者说序列化。它的设计非常适用于在网络通讯中的数据载体，很适合做数据存储或 RPC 数据交换格式，它序列化出来的数据量少再加上以 K-V 的方式来存储数据，对消息的版本兼容性非常强，可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。开发者可以通过 ProtoBuf 定义数据结构，然后通过 ProtoBuf 工具生成各种语言版本的数据结构类库，用于操作 ProtoBuf 协议数据</p>
<p>Protobuf是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于（数据）通信协议、数据存储等。</p>
<p>Protocol Buffers 是一种灵活，高效，自动化机制的结构数据序列化方法－可类比 XML，但是比 XML 更小（3 ~ 10倍）、更快（20 ~ 100倍）、更为简单。json、xml都是基于文本格式，protobuf是二进制格式。</p>
<p>Protobuf中最基本的数据单元是message，是类似Go语言中结构体的存在。在message中可以嵌套message或其它的基础数据类型的成员。</p>
<blockquote>
<p>序列化(serialization、marshalling)的过程是指将数据结构或者对象的状态转换成可以存储(比如文件、内存)或者传输的格式(比如网络)。反向操作就是反序列化(deserialization、unmarshalling)的过程。</p>
</blockquote>
<span id="more"></span>
<p><img src="https://raw.githubusercontent.com/gods-view/images/master/imageimage-20220818145636178.png" alt="image-20220818145636178"></p>
<h1 id="定义Message"><a href="#定义Message" class="headerlink" title="定义Message"></a>定义Message</h1><p>使用 ProtoBuf ，首先需要通过 ProtoBuf 语法定义数据结构(消息)，这些定义好的数据结构保存在.proto为后缀的文件中。</p>
<h2 id="字段类型与字段编号"><a href="#字段类型与字段编号" class="headerlink" title="字段类型与字段编号"></a>字段类型与字段编号</h2><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定protobuf的版本，proto3是最新的语法版本，如果省略protocol buffer编译器默认使用proto2语法。他必须是文件中非空非注释行的第一行</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="comment">// package 定义proto的包名，包名可以避免对message 类型之间的名字冲突，同名的Message可以通过package进行区分。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在没有为特定语言定义option xxx_package的时候，它还可以用来生成特定语言的包名，比如Java package, go package。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Request</span> &#123;</span><br><span class="line">  <span class="type">string</span> userId = <span class="number">1</span>;   <span class="comment">// 定义一个string类型的字段，字段名字为userId, 序号为1</span></span><br><span class="line">  <span class="type">int32</span> operation = <span class="number">2</span>;   <span class="comment">// 定义一个int32类型的字段，字段名字为operation, 序号为2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数据结构，message 你可以想象成Go语言中的struct</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Response</span> &#123;</span><br><span class="line">  <span class="type">string</span> data = <span class="number">1</span>;   <span class="comment">// 定义一个string类型的字段，字段名字为data, 序号为1</span></span><br><span class="line">  <span class="type">int32</span> status = <span class="number">2</span>;   <span class="comment">// 定义一个int32类型的字段，字段名字为status, 序号为2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以给字段指定复合类型，包括枚举类型和其他message类型</span></span><br></pre></td></tr></table></figure>

<p>字段是以<code>[ &quot;repeated&quot; ] type fieldName &quot;=&quot; fieldNumber [ &quot;[&quot; fieldOptions &quot;]&quot; ] &quot;;&quot;</code>格式定义的。这个例子是一个简单的例子，采用了<code>type fieldName &quot;=&quot; fieldNumber</code>格式定义的。</p>
<p>比如第一个字段userId, 首先是它的类型<code>string</code>，其次是字段的名称，然后是等号<code>=</code>, 之后是字段的序号，然后是分号。</p>
<p>复杂的结构，前面可以定义为<code>repeated</code>, 序号之后可以定义一些可选项。</p>
<p>这是普通的字段定义，当然还有一些复杂的一些字段定义，比如<code>Oneof</code>、<code>Map</code>、<code>Reserved</code>、<code>enum</code>定义，下一节我们再详细讲。</p>
<blockquote>
<p>在message定义中每个字段都有一个唯一的编号，这些编号被用来在二进制消息体中识别你定义的这些字段，一旦你的message类型被用到后就不应该在修改这些编号了。注意在将message编码成二进制消息体时字段编号1-15将会占用1个字节，16-2047将占用两个字节。所以在一些频繁使用用的message中，你应该总是先使用前面1-15字段编号。</p>
<p>你可以指定的最小编号是1，最大是2E29 - 1（536,870,911）。其中19000到19999是给protocol buffers实现保留的字段标号，定义message时不能使用。</p>
</blockquote>
<h3 id="保留字段"><a href="#保留字段" class="headerlink" title="保留字段"></a>保留字段</h3><p>当你删掉或者注释掉message中的一个字段时，未来其他开发者在更新message定义时就可以重用之前的字段编号。如果他们意外载入了老版本的<code>.proto</code>文件将会导致严重的问题，比如数据损坏、隐私泄露等。一种避免问题发生的方式是指定保留的字段编号和字段名称。如果未来有人用了这些字段标识那么在编译时protocol buffer的编译器会报错。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Foo</span> &#123;</span><br><span class="line">  reserved <span class="number">2</span>, <span class="number">15</span>, <span class="number">9</span> to <span class="number">11</span>;  <span class="comment">// 保留字段</span></span><br><span class="line">  reserved <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Optional的字段和默认值"><a href="#Optional的字段和默认值" class="headerlink" title="Optional的字段和默认值"></a>Optional的字段和默认值</h3><p>如上所述，消息描述中的一个元素可以被标记为“可选的”（optional）。一个格式良好的消息可以包含0个或一个optional的元素。当解 析消息时，如果它不包含optional的元素值，那么解析出来的对象中的对应字段就被置为默认值。默认值可以在消息描述文件中指定。例如，要为 <em>SearchRequest</em>消息的<em>result_per_page</em>字段指定默认值10，在定义消息格式时如下所示：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="type">int32</span> result_per_page = <span class="number">3</span> [default = <span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>如果没有为optional的元素指定默认值，就会使用与特定类型相关的默认值：对string来说，默认值是空字符串。对bool来说，默认值是false。对数值类型来说，默认值是0。对枚举来说，默认值是枚举类型定义中的第一个值。</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>当需要定义一个消息类型的时候，可能想为一个字段指定某“预定义值序列”中的一个值。例如，假设要为每一个SearchRequest消息添加一个 corpus字段，而corpus的值可能是UNIVERSAL，WEB，IMAGES，LOCAL，NEWS，PRODUCTS或VIDEO中的一个。 其实可以很容易地实现这一点：通过向消息定义中添加一个枚举（enum）就可以了。一个enum类型的字段只能用指定的常量集中的一个值作为其值（如果尝 试指定不同的值，解析器就会把它当作一个未知的字段来对待）。在下面的例子中，在消息格式中添加了一个叫做Corpus的枚举类型——它含有所有可能的值 ——以及一个类型为Corpus的字段：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchRequest</span> &#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">int32</span> result_per_page = <span class="number">3</span> [default = <span class="number">10</span>];</span><br><span class="line">  <span class="keyword">enum </span><span class="title class_">Corpus</span> &#123;</span><br><span class="line">    UNIVERSAL = <span class="number">0</span>;</span><br><span class="line">    WEB = <span class="number">1</span>;</span><br><span class="line">    IMAGES = <span class="number">2</span>;</span><br><span class="line">    LOCAL = <span class="number">3</span>;</span><br><span class="line">    NEWS = <span class="number">4</span>;</span><br><span class="line">    PRODUCTS = <span class="number">5</span>;</span><br><span class="line">    VIDEO = <span class="number">6</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">optional</span> Corpus corpus = <span class="number">4</span> [default = UNIVERSAL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以为枚举常量定义别名。 需要设置allow_alias option 为 true, 否则 protocol编译器会产生错误信息。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum </span><span class="title class_">EnumAllowingAlias</span> &#123;</span><br><span class="line">  <span class="keyword">option</span> allow_alias = <span class="literal">true</span>;</span><br><span class="line">  UNKNOWN = <span class="number">0</span>; <span class="comment">// 枚举类型的第一个选项的标识符必须是0，这也是枚举类型的默认值。</span></span><br><span class="line">  STARTED = <span class="number">1</span>;</span><br><span class="line">  RUNNING = <span class="number">1</span>; <span class="comment">// 如果设置allow_alias，允许字段编号重复，RUNNING是STARTED的别名。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum </span><span class="title class_">EnumNotAllowingAlias</span> &#123;</span><br><span class="line">  UNKNOWN2 = <span class="number">0</span>;</span><br><span class="line">  STARTED2 = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// RUNNING = 1;  // Uncommenting this line will cause a compile error inside Google and a warning message outside.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举常量必须在32位整型值的范围内。因为enum值是使用可变编码方式的，对负数不够高效，因此不推荐在enum中使用负数。如上例所示，可以在 一个消息定义的内部或外部定义枚举——这些枚举可以在.proto文件中的任何消息定义里重用。当然也可以在一个消息中声明一个枚举类型，而在另一个不同 的消息中使用它——采用MessageType.EnumType的语法格式。</p>
<p>当对一个使用了枚举的.proto文件运行protocol buffer编译器的时候，生成的代码中将有一个对应的enum（对Java或C++来说），或者一个特殊的EnumDescriptor类（对 Python来说），它被用来在运行时生成的类中创建一系列的整型值符号常量（symbolic constants）。</p>
<p>注意枚举类型的定义采用C++ scoping规则，也就是枚举值是枚举类型的兄弟类型，而不是子类型，所以避免在同一个package定义重名的枚举字段。</p>
<h3 id="Oneof"><a href="#Oneof" class="headerlink" title="Oneof"></a>Oneof</h3><p>如果你有一组字段，同时最多允许这一组中的一个字段出现，就可以使用<code>Oneof</code>定义这一组字段，这有点Union的意思，但是Oneof允许你设置零各值。</p>
<p>因为proto3没有办法区分正常的值是否是设置了还是取得缺省值(比如int64类型字段，如果它的值是0，你无法判断数据是否包含这个字段，因为0几可能是数据中设置的值，也可能是这个字段的零值)，所以你可以通过Oneof取得这个功能，因为Oneof有判断字段是否设置的功能。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">OneofMessage</span> &#123;</span><br><span class="line">    <span class="keyword">oneof</span> test_oneof &#123;</span><br><span class="line">      <span class="type">string</span> name = <span class="number">4</span>;</span><br><span class="line">      <span class="type">int64</span> value = <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>oneof</code>字段不能同时使用<code>repeated</code>。</p>
<h3 id="map类型"><a href="#map类型" class="headerlink" title="map类型"></a>map类型</h3><p>map类型需要设置键和值的类型，格式是<code>&quot;map&quot; &quot;&lt;&quot; keyType &quot;,&quot; type &quot;&gt;&quot; mapName &quot;=&quot; fieldNumber [ &quot;[&quot; fieldOptions &quot;]&quot;</code>。</p>
<p>比如:</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int64</span>,<span class="type">string</span>&gt; values = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><code>map</code>字段不能同时使用<code>repeated</code>。</p>
<h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><p><code>Any</code>字段允许你处理嵌套数据，并不需要它的proto定义。一个<code>Any</code>以bytes呈现序列化的消息，并且包含一个URL作为这个类型的唯一标识和元数据。</p>
<p>为了使用<code>Any</code>类型，你需要引入<code>google/protobuf/any.proto</code>。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/any.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ErrorStatus</span> &#123;</span><br><span class="line">  <span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">repeated</span> google.protobuf.Any details = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Any类型用来替换proto2中的扩展。</p>
<h3 id="使用其他消息类型"><a href="#使用其他消息类型" class="headerlink" title="使用其他消息类型"></a>使用其他消息类型</h3><p>你可以将其他消息类型用作字段类型。例如，假设在每一个SearchResponse消息中包含Result消息，此时可以在相同的.proto文件中定义一个Result消息类型，然后在SearchResponse消息中指定一个Result类型的字段，如：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchResponse</span> &#123;</span><br><span class="line">  <span class="keyword">repeated</span> Result result = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Result</span> &#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">string</span> url = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">string</span> title = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="type">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="导入定义"><a href="#导入定义" class="headerlink" title="导入定义"></a>导入定义</h3><p>在上面的例子中，Result消息类型与SearchResponse是定义在同一文件中的。如果想要使用的消息类型已经在其他.proto文件中已经定义过了呢？<br>你可以通过导入（importing）其他.proto文件中的定义来使用它们。要导入其他.proto文件的定义，你需要在你的文件中添加一个导入声明，如：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;myproject/other_protos.proto&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>默认情况下你只能使用直接导入的.proto文件中的定义. 然而， 有时候你需要移动一个.proto文件到一个新的位置， 可以不直接移动.proto文件， 只需放入一个dummy .proto 文件在老的位置， 然后使用import转向新的位置:</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// new.proto</span></span><br><span class="line"><span class="comment">// All definitions are moved here</span></span><br><span class="line"><span class="comment">// old.proto</span></span><br><span class="line"><span class="comment">// This is the proto that all clients are importing.</span></span><br><span class="line"><span class="keyword">import</span> public <span class="string">&quot;new.proto&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;other.proto&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>// client.proto</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;old.proto&quot;</span>;</span><br><span class="line"><span class="comment">// You use definitions from old.proto and new.proto, but not other.proto</span></span><br></pre></td></tr></table></figure>

<p>protocol编译器就会在一系列目录中查找需要被导入的文件，这些目录通过protocol编译器的命令行参数-I/–import_path指定。如果不提供参数，编译器就在其调用目录下查找。</p>
<h3 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h3><p>你可以在其他消息类型中定义、使用消息类型，在下面的例子中，Result消息就定义在SearchResponse消息内，如：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchResponse</span> &#123;</span><br><span class="line">  <span class="keyword">message </span><span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">string</span> url = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="type">string</span> title = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">repeated</span> Result result = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想在它的父消息类型的外部重用这个消息类型，你需要以Parent.Type的形式使用它，如：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SomeOtherMessage</span> &#123;</span><br><span class="line">  <span class="keyword">optional</span> SearchResponse.Result result = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，你也可以将消息嵌套任意多层，如：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Outer</span> &#123;                  <span class="comment">// Level 0</span></span><br><span class="line">  <span class="keyword">message </span><span class="title class_">MiddleAA</span> &#123;  <span class="comment">// Level 1</span></span><br><span class="line">    <span class="keyword">message </span><span class="title class_">Inner</span> &#123;   <span class="comment">// Level 2</span></span><br><span class="line">      <span class="keyword">required</span> <span class="type">int64</span> ival = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">optional</span> <span class="type">bool</span>  booly = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">message </span><span class="title class_">MiddleBB</span> &#123;  <span class="comment">// Level 1</span></span><br><span class="line">    <span class="keyword">message </span><span class="title class_">Inner</span> &#123;   <span class="comment">// Level 2</span></span><br><span class="line">      <span class="keyword">required</span> <span class="type">int32</span> ival = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">optional</span> <span class="type">bool</span>  booly = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更新一个消息类型"><a href="#更新一个消息类型" class="headerlink" title="更新一个消息类型"></a>更新一个消息类型</h3><p>==如果一个已有的消息格式已无法满足新的需求——如，要在消息中添加一个额外的字段——但是同时旧版本写的代码仍然可用。不用担心！更新消息而不破坏已有代码是非常简单的。在更新时只要记住以下的规则即可。==</p>
<ul>
<li>不要更改任何已有的字段的数值标识。<br>所添加的任何字段都必须是optional或repeated的。这就意味着任何使用“旧”的消息格式的代码序列化的消息可以被新的代码所解析，因为它们 不会丢掉任何required的元素。应该为这些元素设置合理的默认值，这样新的代码就能够正确地与老代码生成的消息交互了。类似地，新的代码创建的消息 也能被老的代码解析：老的二进制程序在解析的时候只是简单地将新字段忽略。然而，未知的字段是没有被抛弃的。此后，如果消息被序列化，未知的字段会随之一 起被序列化——所以，如果消息传到了新代码那里，则新的字段仍然可用。注意：对Python来说，对未知字段的保留策略是无效的。</li>
<li>非required的字段可以移除——只要它们的标识号在新的消息类型中不再使用（更好的做法可能是重命名那个字段，例如在字段前添加“OBSOLETE_”前缀，那样的话，使用的.proto文件的用户将来就不会无意中重新使用了那些不该使用的标识号）。</li>
<li>一个非required的字段可以转换为一个扩展，反之亦然——只要它的类型和标识号保持不变。</li>
<li>int32, uint32, int64, uint64,和bool是全部兼容的，这意味着可以将这些类型中的一个转换为另外一个，而不会破坏向前、 向后的兼容性。如果解析出来的数字与对应的类型不相符，那么结果就像在C++中对它进行了强制类型转换一样（例如，如果把一个64位数字当作int32来 读取，那么它就会被截断为32位的数字）。</li>
<li>sint32和sint64是互相兼容的，但是它们与其他整数类型不兼容。</li>
<li>string和bytes是兼容的——只要bytes是有效的UTF-8编码。</li>
<li>嵌套消息与bytes是兼容的——只要bytes包含该消息的一个编码过的版本。</li>
<li>fixed32与sfixed32是兼容的，fixed64与sfixed64是兼容的。</li>
</ul>
<h2 id="proto文件编译"><a href="#proto文件编译" class="headerlink" title="proto文件编译"></a>proto文件编译</h2><p>将.proto文件，编译成指定语言类库</p>
<h3 id="安装Protobuf编译器"><a href="#安装Protobuf编译器" class="headerlink" title="安装Protobuf编译器"></a>安装Protobuf编译器</h3><p>protobuf的github发布地址： <a href="https://github.com/protocolbuffers/protobuf/releases">https://github.com/protocolbuffers/protobuf/releases</a></p>
<p>protobuf的编译器叫protoc，在上面的网址中找到最新版本的安装包，下载安装。</p>
<ol>
<li><code>unzip protoc-****-osx-x86_64.zip</code></li>
<li><code>cp -r include/ /usr/local/include/  # 一个&quot;/&quot;都不能少</code></li>
<li><code>cp -r bin/ /usr/local/bin/  # 一个&quot;/&quot;都不能少</code></li>
</ol>
<p>打开cmd，命令窗口执行protoc命令，没有报错的话，就已经安装成功。</p>
<h3 id="安装protoc-gen-go插件"><a href="#安装protoc-gen-go插件" class="headerlink" title="安装protoc-gen-go插件"></a>安装protoc-gen-go插件</h3><p>Protobuf核心的工具集是C++语言开发的，官方的protoc编译器中并不支持Go语言，需要安装一个插件才能生成Go代码。用如下命令安装：</p>
<p><code>go get -u -v github.com/golang/protobuf/protoc-gen-go@v1.3.0 // 指定protoc-gen-go的版本</code></p>
<p>提供了一个<code>protoc-gen-go</code>二进制文件，当编译器调用时传递了<code>--go_out</code>命令行标志时<code>protoc</code>就会使用它。<code>--go_out</code>告诉编译器把Go源代码写到哪里。编译器会为每个<code>.proto</code>文件生成一个单独的源代码文件。</p>
<h3 id="编译对应语言的pb文件"><a href="#编译对应语言的pb文件" class="headerlink" title="编译对应语言的pb文件"></a>编译对应语言的pb文件</h3><p>在当前的目录下执行<code>protoc -I=. -I/usr/local/include -I=$(GOPATH)/src --go_out=. simple.proto</code>, 可以将这个proto编译成Go的代码，因为这里我们使用了<code>go_out</code>输出格式。</p>
<p><code>-I</code>指定protoc的搜索import的proto的文件夹。在<code>MacOS</code>操作系统中protobuf把一些扩展的proto放在了<code>/usr/local/include</code>对应的文件夹中，一些第三方的Go库放在了gopath对应的包下，所以这里都把它们加上了。对于这个简单的例子，实际是不需要的。</p>
<p><code>cpp_out</code>用来生成C++代码，<code>java_out</code>产生Java代码，<code>python_out</code>产生python代码，类似地还有<code>csharp_out</code>、<code>objc_out</code>、<code>ruby_out</code>、<code>php_out</code>等参数。</p>
<p>一些第三方的插件也会定义自己的输出插件，比如<code>gofast_out</code>使用gogo库生成代码， <code>rust_out</code>产生rust代码。</p>
<p>生成的代码我们指定放在本地文件夹中(<code>--go_out=.</code>)。</p>
<p>输出文件的名称是通过获取.proto文件的名称并进行两处更改来计算的：</p>
<ul>
<li>生成文件的扩展名是<code>.pb.go</code>。比如说<code>user.proto</code>编译后会得到<code>user.pb.go</code>。</li>
<li>proto路径（使用<code>--proto_path</code>或<code>-I</code>命令行标志指定）将替换为输出路径（使用<code>--go_out</code>标志指定）。</li>
</ul>
<p>当你运行如下编译命令时：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">protoc --proto_path=src --go_out=build/gen src/foo.proto src/bar/baz.proto</span><br></pre></td></tr></table></figure>

<p>编译器会读取文件<code>src/foo.proto</code>和<code>src/bar/baz.proto</code>，这将会生成两个输出文件<code>build/gen/foo.pb.go</code>和<code>build/gen/bar/baz.pb.go</code></p>
<p>如果有必要，编译器会自动生成<code>build/gen/bar</code>目录，但是他不能创建<code>build</code>或者<code>build/gen</code>目录，这两个必须是已经存在的目录。</p>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>如果一个<code>.proto</code>文件中有包声明，生成的源代码将会使用它来作为Go的包名，如果<code>.proto</code>的包名中有<code>.</code> 在Go包名中会将<code>.</code>转换为<code>_</code>。举例来说<code>proto</code>包名<code>example.high_score</code>将会生成Go包名<code>example_high_score</code>。</p>
<p>在<code>.proto</code>文件中可以使用option <code>go_package</code>指令来覆盖上面默认生成Go包名的规则。比如说包含如下指令的一个<code>.proto</code>文件</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example.high_score;</span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;hs&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>生成的Go源代码的包名是<code>hs</code>。</p>
<p>如果一个<code>.proto</code>文件中不包含package声明，生成的源代码将会使用<code>.proto</code>文件的文件名(去掉扩展名)作为Go包名，<code>.</code>会被首先转换为<code>_</code>。举例来说一个名为<code>high.score.proto</code>不包含pack声明的文件将会生成文件<code>high.score.pb.go</code>，他的Go包名是<code>high_score</code>。</p>
<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>一个简单的消息声明：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Foo</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>protocol buffer编译器将会生成一个名为<code>Foo</code>的结构体，实现了<code>proto.Message</code>接口的<code>Foo</code>类型的指针</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">type Foo struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置proto为默认值</span></span><br><span class="line">func (m *Foo) Reset()         &#123; *m = Foo&#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String 返回proto的字符串表示</span></span><br><span class="line">func (m *Foo) String() <span class="type">string</span> &#123; return proto.CompactTextString(m) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProtoMessage作为一个tag 确保其他人不会意外的实现</span></span><br><span class="line"><span class="comment">// proto.Message 接口.</span></span><br><span class="line">func (*Foo) ProtoMessage()    &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内嵌的消息"><a href="#内嵌的消息" class="headerlink" title="内嵌的消息"></a>内嵌的消息</h3><p>一个message可以声明在其他message的内部。比如说：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">message </span><span class="title class_">Bar</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况，编译器会生成两个结构体：<code>Foo</code>和<code>Foo_Bar</code>。</p>
<h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p>编译器会为每个在message中定义的字段生成一个Go结构体的字段，字段的确切性质取决于它的类型以及它是<code>singular</code>，<code>repeated</code>，<code>map</code>还是<code>oneof</code>字段。</p>
<p>注意生成的Go结构体的字段将始终使用驼峰命名，即使在<code>.proto</code>文件中消息字段用的是小写加下划线（应该这样）。大小写转换的原理如下：</p>
<ul>
<li>首字母会大些，如果message中字段的第一个字符是<code>_</code>，它将被替换为X。</li>
<li>如果内部下划线后跟小写字母，则删除下划线，并将后面跟随的字母大写。</li>
</ul>
<p>因此，proto字段<code>foo_bar_baz</code>在Go中变成<code>FooBarBaz</code>， <code>_my_field_name_2</code>变为<code>XMyFieldName_2</code>。</p>
<h3 id="单一标量字段"><a href="#单一标量字段" class="headerlink" title="单一标量字段"></a>单一标量字段</h3><p>对于字段定义：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="type">int32</span> foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>编译器将生成一个带有名为Foo的int32字段和一个访问器方法GetFoo（）的结构，该方法返回Foo中的int32值或该字段的零值（如果字段未设置（数值型零值为0，字符串为空字符串））。</p>
<h3 id="单一message字段"><a href="#单一message字段" class="headerlink" title="单一message字段"></a>单一message字段</h3><p>给出如下消息类型</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Bar</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>对于一个有<code>Bar</code>类型字段的消息：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// proto3</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Baz</span> &#123;</span><br><span class="line">  Bar foo = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器将会生成一个Go结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Baz <span class="keyword">struct</span> &#123;</span><br><span class="line">        Foo *Bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息类型的字段可以设置为nil，这意味着该字段未设置，有效清除该字段。这不等同于将值设置为消息结构体的“空”实例。</p>
<p>编译器还生成一个<code>func（m * Baz）GetFoo（）* Bar</code>辅助函数。这让不在中间检查nil值进行链式调用成为可能。</p>
<h3 id="可重复字段"><a href="#可重复字段" class="headerlink" title="可重复字段"></a>可重复字段</h3><p>每个重复的字段在Go中的结构中生成一个T类型的slice，其中T是字段的元素类型。对于带有重复字段的此消息：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Baz</span> &#123;</span><br><span class="line">  <span class="keyword">repeated</span> Bar foo = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会生成如下结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Baz <span class="keyword">struct</span> &#123;</span><br><span class="line">        Foo  []*Bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，对于字段定义<code>repeated bytes foo = 1;</code>编译器将会生成一个带有类型为<code>[][]byte</code>名为<code>Foo</code>的字段的Go结构体。对于可重复的枚举<code>repeated MyEnum bar = 2;</code>，编译器会生成带有类型为<code>[]MyEnum</code>名为<code>Bar</code>的字段的Go结构体。</p>
<h3 id="映射字段"><a href="#映射字段" class="headerlink" title="映射字段"></a>映射字段</h3><p>每个映射字段会在Go的结构体中生成一个<code>map[TKey]TValue</code>类型的字段，其中<code>TKey</code>是字段的键类型<code>TValue</code>是字段的值类型。对于下面这个消息定义：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Bar</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Baz</span> &#123;</span><br><span class="line">  map&lt;<span class="type">string</span>, Bar&gt; foo = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器生成Go结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Baz <span class="keyword">struct</span> &#123;</span><br><span class="line">        Foo <span class="keyword">map</span>[<span class="type">string</span>]*Bar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举-1"><a href="#枚举-1" class="headerlink" title="枚举"></a>枚举</h2><p>给出如下枚举</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">SearchRequest</span> &#123;</span><br><span class="line">  <span class="keyword">enum </span><span class="title class_">Corpus</span> &#123;</span><br><span class="line">    UNIVERSAL = <span class="number">0</span>;</span><br><span class="line">    WEB = <span class="number">1</span>;</span><br><span class="line">    IMAGES = <span class="number">2</span>;</span><br><span class="line">    LOCAL = <span class="number">3</span>;</span><br><span class="line">    NEWS = <span class="number">4</span>;</span><br><span class="line">    PRODUCTS = <span class="number">5</span>;</span><br><span class="line">    VIDEO = <span class="number">6</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Corpus corpus = <span class="number">1</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器将会生成一个枚举类型和一系列该类型的常量。</p>
<p>对于消息中的枚举（像上面那样），类型名字以消息名开头</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SearchRequest_Corpus <span class="type">int32</span></span><br></pre></td></tr></table></figure>

<p>对于包级别的枚举：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .proto</span></span><br><span class="line"><span class="keyword">enum </span><span class="title class_">Foo</span> &#123;</span><br><span class="line">  DEFAULT_BAR = <span class="number">0</span>;</span><br><span class="line">  BAR_BELLS = <span class="number">1</span>;</span><br><span class="line">  BAR_B_CUE = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 中的类型不会对proto中的枚举名称进行修改：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="type">int32</span></span><br></pre></td></tr></table></figure>

<p>此类型具有<code>String()</code>方法，该方法返回给定值的名称。</p>
<p><code>Enum()</code>方法使用给定值初始化新分配的内存并返回相应的指针：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Foo)</span></span> Enum() *Foo</span><br></pre></td></tr></table></figure>

<p>编译器为枚举中的每个值生成一个常量。对于消息中的枚举，常量以消息的名称开头：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        SearchRequest_UNIVERSAL SearchRequest_Corpus = <span class="number">0</span></span><br><span class="line">        SearchRequest_WEB       SearchRequest_Corpus = <span class="number">1</span></span><br><span class="line">        SearchRequest_IMAGES    SearchRequest_Corpus = <span class="number">2</span></span><br><span class="line">        SearchRequest_LOCAL     SearchRequest_Corpus = <span class="number">3</span></span><br><span class="line">        SearchRequest_NEWS      SearchRequest_Corpus = <span class="number">4</span></span><br><span class="line">        SearchRequest_PRODUCTS  SearchRequest_Corpus = <span class="number">5</span></span><br><span class="line">        SearchRequest_VIDEO     SearchRequest_Corpus = <span class="number">6</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>对于包级别的枚举，常量以枚举名称开头:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">        Foo_DEFAULT_BAR Foo = <span class="number">0</span></span><br><span class="line">        Foo_BAR_BELLS   Foo = <span class="number">1</span></span><br><span class="line">        Foo_BAR_B_CUE   Foo = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>protobuf编译器还生成从整数值到字符串名称的映射以及从名称到值的映射：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo_name = <span class="keyword">map</span>[<span class="type">int32</span>]<span class="type">string</span>&#123;</span><br><span class="line">        <span class="number">0</span>: <span class="string">&quot;DEFAULT_BAR&quot;</span>,</span><br><span class="line">        <span class="number">1</span>: <span class="string">&quot;BAR_BELLS&quot;</span>,</span><br><span class="line">        <span class="number">2</span>: <span class="string">&quot;BAR_B_CUE&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Foo_value = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int32</span>&#123;</span><br><span class="line">        <span class="string">&quot;DEFAULT_BAR&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;BAR_BELLS&quot;</span>:   <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;BAR_B_CUE&quot;</span>:   <span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，<code>.proto</code>语言允许多个枚举符号具有相同的数值。具有相同数值的符号是同义词。这些在Go中以完全相同的方式表示，多个名称对应于相同的数值。反向映射包含数字值的单个条目，数值映射到出现在<code>proto</code>文件中首先出现的名称。</p>
]]></content>
      <tags>
        <tag>Protobuf</tag>
      </tags>
  </entry>
</search>
